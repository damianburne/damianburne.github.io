<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Immersive Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Roboto, sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-input { transform: scaleX(-1); display: none; } 
        
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; text-align: center; z-index: 10;
            pointer-events: none; transition: opacity 0.5s;
        }

        #hud {
            position: absolute; bottom: 30px; left: 30px; 
            color: rgba(255,255,255,0.6); z-index: 5; pointer-events: none;
            font-size: 14px; line-height: 1.6;
            background: rgba(0,0,0,0.6); padding: 15px; border-radius: 8px;
            backdrop-filter: blur(4px);
        }

        /* --- Popups --- */
        .glass-panel {
            position: absolute; 
            backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
            border-radius: 16px; padding: 24px; color: white;
            z-index: 20; opacity: 0;
            transform: translateY(20px) scale(0.95);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        .glass-panel.active { opacity: 1; transform: translateY(0) scale(1); }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 12px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px; }
        .stat-label { font-size: 12px; text-transform: uppercase; letter-spacing: 1px; color: #ccc; }
        h2 { margin-top: 0; font-weight: 300; font-size: 22px; margin-bottom: 20px; }

        /* 2-Finger Popup (Standard/Red) */
        #popup-2 {
            top: 20%; right: 10%; width: 280px;
            background: rgba(40, 0, 0, 0.75);
            border: 1px solid rgba(255, 50, 50, 0.4);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.2);
        }
        #popup-2 .stat-val { color: #ff4444; font-weight: bold; font-size: 18px; text-shadow: 0 0 10px rgba(255,0,0,0.4); }

        /* 3-Finger Popup (Detailed/Multi-color) */
        #popup-3 {
            top: 15%; left: 10%; width: 400px;
            background: rgba(10, 20, 30, 0.85);
            border: 1px solid rgba(100, 200, 255, 0.3);
            box-shadow: 0 0 40px rgba(0, 100, 255, 0.2);
        }
        #popup-3 h2 { border-bottom: 2px solid #fff; padding-bottom: 10px; }
        
        .val-green { color: #00ff88; font-weight: bold; text-shadow: 0 0 8px rgba(0,255,100,0.4); }
        .val-yellow { color: #ffcc00; font-weight: bold; text-shadow: 0 0 8px rgba(255,200,0,0.4); }
        .val-red { color: #ff4444; font-weight: bold; text-shadow: 0 0 8px rgba(255,50,50,0.4); }

    </style>
</head>
<body>

    <div id="loader">Initializing Immersive View...<br><span style="font-size:14px; opacity:0.7">Please allow camera access</span></div>
    
    <div id="hud">
        <b>Interaction Guide:</b><br>
        • Hand Far (Small): <b>Zoom IN</b><br>
        • Hand Close (Big): <b>Zoom OUT</b><br>
        • 1 Finger: <b>Focus Network</b><br>
        • 2 Fingers: <b>Basic Data</b><br>
        • 3 Fingers: <b>Full Analytics</b>
    </div>

    <!-- 2 Fingers: Standard Red Popup -->
    <div id="popup-2" class="glass-panel">
        <h2>Critical Overview</h2>
        <div class="stat-row">
            <span class="stat-label">System Load</span>
            <span class="stat-val">94%</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Errors / Hr</span>
            <span class="stat-val">12</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Active Nodes</span>
            <span class="stat-val">15,420</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Status</span>
            <span class="stat-val">ALERT</span>
        </div>
    </div>

    <!-- 3 Fingers: Detailed Multi-Color Popup -->
    <div id="popup-3" class="glass-panel">
        <h2>Global Analytics Dashboard</h2>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <div>
                <div class="stat-row"><span class="stat-label">Revenue</span><span class="val-green">▲ $4.2M</span></div>
                <div class="stat-row"><span class="stat-label">Growth</span><span class="val-green">+18.5%</span></div>
                <div class="stat-row"><span class="stat-label">Uptime</span><span class="val-green">99.9%</span></div>
            </div>
            <div>
                <div class="stat-row"><span class="stat-label">Latency</span><span class="val-yellow">145ms</span></div>
                <div class="stat-row"><span class="stat-label">Churn</span><span class="val-yellow">4.2%</span></div>
                <div class="stat-row"><span class="stat-label">Threats</span><span class="val-red">DETECTED</span></div>
            </div>
        </div>
        <div style="margin-top: 15px; font-size: 12px; color: #888; border-top: 1px solid #333; padding-top: 10px;">
            Live stream aggregation from 4 regions. Neural projection mapping active.
        </div>
    </div>

    <div id="canvas-container"></div>
    <video id="video-input"></video>

    <!-- Import Maps -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'three/addons/libs/lil-gui.module.min.js';

        // --- Config ---
        const PARTICLE_COUNT = 12000; // Increased for immersive feel
        const HIGHLIGHT_COUNT = 160; 
        const LINE_DISTANCE = 4.2; 

        const config = {
            shape: 'Sphere',
            color: '#0088ff',
            handScale: 1.5, // Start larger
            rotationX: 0,
            rotationY: 0,
            focusMode: false 
        };

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.025); // Slightly denser fog for depth

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        // MOVED CLOSER: Was 22, now 14. This brings the viewer right up to the object.
        camera.position.z = 14; 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.enableZoom = false; 

        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // --- Textures ---
        function getTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            
            if(type === 'red') {
                grad.addColorStop(0, 'rgba(255, 60, 60, 1)');
                grad.addColorStop(0.3, 'rgba(200, 0, 0, 0.9)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
            } else {
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(0.2, 'rgba(200,220,255,0.8)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
            }
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            const t = new THREE.Texture(canvas);
            t.needsUpdate = true;
            return t;
        }

        // --- Systems ---
        // 1. Blue Field
        const geoMain = new THREE.BufferGeometry();
        const posMain = new Float32Array(PARTICLE_COUNT * 3);
        const targMain = new Float32Array(PARTICLE_COUNT * 3);
        for(let i=0; i<PARTICLE_COUNT*3; i++) {
            posMain[i] = (Math.random()-0.5)*50;
            targMain[i] = posMain[i];
        }
        geoMain.setAttribute('position', new THREE.BufferAttribute(posMain, 3));
        const matMain = new THREE.PointsMaterial({
            size: 0.10, // Slightly smaller since we are closer
            color: config.color, map: getTexture('blue'),
            transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false
        });
        const sysMain = new THREE.Points(geoMain, matMain);
        mainGroup.add(sysMain);

        // 2. Red Highlights
        const geoHigh = new THREE.BufferGeometry();
        const posHigh = new Float32Array(HIGHLIGHT_COUNT * 3);
        const targHigh = new Float32Array(HIGHLIGHT_COUNT * 3);
        for(let i=0; i<HIGHLIGHT_COUNT*3; i++) {
            posHigh[i] = (Math.random()-0.5)*50;
            targHigh[i] = posHigh[i];
        }
        geoHigh.setAttribute('position', new THREE.BufferAttribute(posHigh, 3));
        const matHigh = new THREE.PointsMaterial({
            size: 0.85, 
            color: 0xff4444, map: getTexture('red'),
            transparent: true, opacity: 0.95, blending: THREE.AdditiveBlending, depthWrite: false
        });
        const sysHigh = new THREE.Points(geoHigh, matHigh);
        mainGroup.add(sysHigh);

        // 3. Network Lines
        const lineMax = HIGHLIGHT_COUNT * 12;
        const lineGeo = new THREE.BufferGeometry();
        const linePos = new Float32Array(lineMax * 3); 
        lineGeo.setAttribute('position', new THREE.BufferAttribute(linePos, 3));
        
        const lineMat = new THREE.LineBasicMaterial({
            color: 0xff1111, // Stronger red
            transparent: true, 
            opacity: 0.5, 
            blending: THREE.AdditiveBlending
        });
        const lineSys = new THREE.LineSegments(lineGeo, lineMat);
        mainGroup.add(lineSys);

        // --- Shapes ---
        function getSpherePoint(r) {
            const u = Math.random(); const v = Math.random();
            const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1);
            return [ r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi) ];
        }

        const shapes = {
            Sphere: (i) => getSpherePoint(6), // Radius 6
            Cube: (i) => [(Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10],
            Galaxy: (i) => {
                const angle = Math.random()*Math.PI*2;
                const r = 2 + Math.random()*8;
                return [ Math.cos(angle+r*2)*r, (Math.random()-0.5)*2, Math.sin(angle+r*2)*r ];
            }
        };

        function updateShape(name) {
            const gen = shapes[name];
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const p = gen(i);
                targMain[i*3]=p[0]; targMain[i*3+1]=p[1]; targMain[i*3+2]=p[2];
            }
            for(let i=0; i<HIGHLIGHT_COUNT; i++) {
                const p = gen(i);
                targHigh[i*3]=p[0]*1.1; targHigh[i*3+1]=p[1]*1.1; targHigh[i*3+2]=p[2]*1.1;
            }
        }
        updateShape('Sphere');

        const gui = new GUI({ title: 'System Controls' });
        gui.add(config, 'shape', Object.keys(shapes)).onChange(updateShape);

        // --- Interaction Logic ---
        const videoElement = document.getElementById('video-input');
        const pop2 = document.getElementById('popup-2');
        const pop3 = document.getElementById('popup-3');

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onHandsResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraFeed.start();

        // Finger States
        function getFingerState(lm) {
            const isRaised = (tipIdx, pipIdx) => lm[tipIdx].y < lm[pipIdx].y;
            const index = isRaised(8, 6);
            const middle = isRaised(12, 10);
            const ring = isRaised(16, 14);
            const pinky = isRaised(20, 18);

            if(index && middle && ring && !pinky) return 3;
            if(index && middle && !ring && !pinky) return 2;
            if(index && !middle && !ring && !pinky) return 1;
            return 0;
        }

        function getHandSize(lm) {
            const dx = lm[0].x - lm[9].x;
            const dy = lm[0].y - lm[9].y;
            return Math.sqrt(dx*dx + dy*dy);
        }

        function onHandsResults(results) {
            document.getElementById('loader').style.opacity = 0;
            const landmarks = results.multiHandLandmarks;

            let gesture = 0;

            if (landmarks && landmarks.length > 0) {
                const lm = landmarks[0]; 
                gesture = getFingerState(lm);

                // --- ZOOM / SCALE LOGIC ---
                // Size range: 0.05 (Far) to 0.25 (Close)
                const size = getHandSize(lm);
                
                // INVERTED & CLOSER:
                // Hand Far (0.05) -> Huge Scale (3.5) -> Viewers feels INSIDE the sphere
                // Hand Close (0.25) -> Standard Scale (0.8) -> Viewers sees the whole sphere close up
                let targetScale = THREE.MathUtils.mapLinear(size, 0.05, 0.25, 3.5, 0.8); 
                targetScale = THREE.MathUtils.clamp(targetScale, 0.8, 3.5);
                
                config.handScale = THREE.MathUtils.lerp(config.handScale, targetScale, 0.1);

                // Rotation
                const cx = lm[9].x; 
                const cy = lm[9].y;
                config.rotationY = (0.5 - cx) * 3; 
                config.rotationX = (cy - 0.5) * 3; 
            } else {
                config.handScale = THREE.MathUtils.lerp(config.handScale, 1.2, 0.05); // Idle at a nice size
                config.rotationY += 0.002;
            }

            // UI
            config.focusMode = (gesture === 1); 

            if(gesture === 2) pop2.classList.add('active');
            else pop2.classList.remove('active');

            if(gesture === 3) pop3.classList.add('active');
            else pop3.classList.remove('active');
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, config.rotationY, 0.1);
            mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, config.rotationX, 0.1);

            // Focus Mode Visuals
            if(config.focusMode) {
                matMain.opacity = THREE.MathUtils.lerp(matMain.opacity, 0.05, 0.1); // Darken Main
                lineMat.opacity = THREE.MathUtils.lerp(lineMat.opacity, 0.9, 0.1); // Brighten Lines
                matHigh.size = THREE.MathUtils.lerp(matHigh.size, 1.0, 0.1);
            } else {
                matMain.opacity = THREE.MathUtils.lerp(matMain.opacity, 0.6, 0.1); 
                lineMat.opacity = THREE.MathUtils.lerp(lineMat.opacity, 0.4, 0.1);
                matHigh.size = THREE.MathUtils.lerp(matHigh.size, 0.85, 0.1);
            }

            const speed = 0.08;
            
            // Particles
            const posM = geoMain.attributes.position.array;
            for(let i=0; i<PARTICLE_COUNT*3; i+=3) {
                posM[i] += (targMain[i]*config.handScale - posM[i]) * speed;
                posM[i+1] += (targMain[i+1]*config.handScale - posM[i+1]) * speed;
                posM[i+2] += (targMain[i+2]*config.handScale - posM[i+2]) * speed;
            }
            geoMain.attributes.position.needsUpdate = true;

            // Highlights
            const posH = geoHigh.attributes.position.array;
            const activePoints = [];

            for(let i=0; i<HIGHLIGHT_COUNT*3; i+=3) {
                posH[i] += (targHigh[i]*config.handScale - posH[i]) * speed;
                posH[i+1] += (targHigh[i+1]*config.handScale - posH[i+1]) * speed;
                posH[i+2] += (targHigh[i+2]*config.handScale - posH[i+2]) * speed;
                activePoints.push({x: posH[i], y: posH[i+1], z: posH[i+2]});
            }
            geoHigh.attributes.position.needsUpdate = true;

            // Lines
            let lineIdx = 0;
            const lineArr = lineGeo.attributes.position.array;
            const connectDist = LINE_DISTANCE * config.handScale; 
            const connectDistSq = connectDist * connectDist;

            for(let i=0; i<activePoints.length; i++) {
                for(let j=i+1; j<activePoints.length; j++) {
                    const p1 = activePoints[i];
                    const p2 = activePoints[j];
                    const dSq = (p1.x-p2.x)**2 + (p1.y-p2.y)**2 + (p1.z-p2.z)**2;
                    
                    if(dSq < connectDistSq) {
                        if(lineIdx < lineArr.length-6) {
                            lineArr[lineIdx++] = p1.x; lineArr[lineIdx++] = p1.y; lineArr[lineIdx++] = p1.z;
                            lineArr[lineIdx++] = p2.x; lineArr[lineIdx++] = p2.y; lineArr[lineIdx++] = p2.z;
                        }
                    }
                }
            }
            lineGeo.setDrawRange(0, lineIdx/3);
            lineGeo.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>