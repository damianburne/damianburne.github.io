<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Memory Bubbles - Insight Mode</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --accent-color: #0071e3;
            /* Apple System Blue */
            --accent-secondary: #34c759;
            /* Apple System Green */
            --glass-bg: rgba(255, 255, 255, 0.75);
            --glass-border: rgba(255, 255, 255, 0.8);
            --text-primary: #1d1d1f;
            --text-secondary: #86868b;
            --card-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #ffffff;
            font-family: 'Inter', sans-serif;
            touch-action: none;
            color: var(--text-primary);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            transition: filter 0.5s ease;
        }

        /* --- UI Overlay (Minority Report Style - Light Mode) --- */
        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
            perspective: 1000px;
            opacity: 0;
            visibility: hidden;
        }

        #ui-layer.active {
            pointer-events: auto;
            visibility: visible;
        }

        .ui-container {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            grid-template-rows: repeat(12, 1fr);
            width: 90vw;
            height: 85vh;
            gap: 20px;
            position: relative;
        }

        /* Glass Cards */
        .card {
            background: var(--glass-bg);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 24px;
            padding: 24px;
            box-shadow: var(--card-shadow);
            color: var(--text-primary);
            opacity: 0;
            transform: translateZ(0);
            overflow: hidden;
            position: relative;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, transparent, var(--accent-color), transparent);
            opacity: 0.8;
        }

        /* Specific Card Placements */
        .card-insight {
            grid-column: 2 / 8;
            grid-row: 2 / 5;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .card-pie {
            grid-column: 8 / 12;
            grid-row: 2 / 6;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .card-bar {
            grid-column: 2 / 6;
            grid-row: 5 / 9;
        }

        .card-spark {
            grid-column: 6 / 12;
            grid-row: 6 / 9;
        }

        .card-tags {
            grid-column: 2 / 12;
            grid-row: 9 / 11;
            display: flex;
            align-items: center;
            gap: 16px;
            background: transparent;
            border: none;
            box-shadow: none;
            backdrop-filter: none;
            padding: 0;
        }

        /* Typography & Content */
        h1 {
            font-size: 4rem;
            font-weight: 700;
            margin: 0;
            letter-spacing: -0.03em;
            background: linear-gradient(135deg, #1d1d1f 0%, #434344 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        h3 {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--accent-color);
            margin-bottom: 12px;
            font-weight: 600;
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-top: 8px;
            font-weight: 400;
            line-height: 1.4;
        }

        /* Charts */
        .bar-chart {
            display: flex;
            flex-direction: column;
            gap: 12px;
            height: 100%;
            justify-content: center;
        }

        .bar-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bar-label {
            width: 40px;
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .bar-track {
            flex: 1;
            height: 6px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 3px;
            overflow: hidden;
        }

        .bar-fill {
            height: 100%;
            background: var(--accent-color);
            width: 0%;
            border-radius: 3px;
        }

        /* Pie Chart SVG */
        .pie-svg circle {
            fill: none;
            stroke-width: 32;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            stroke-dasharray: 0 100;
            transition: stroke-dasharray 1s ease-out;
        }

        /* Tags */
        .pill {
            padding: 8px 16px;
            border-radius: 20px;
            background: rgba(0, 113, 227, 0.1);
            border: 1px solid rgba(0, 113, 227, 0.2);
            color: var(--accent-color);
            font-size: 0.9rem;
            font-weight: 500;
            opacity: 0;
            transform: translateY(10px);
        }

        /* Background Particles in UI */
        .bg-particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            background: radial-gradient(circle at 50% 50%, rgba(0, 113, 227, 0.03), transparent 70%);
        }

        #cursor {
            position: fixed;
            top: 0;
            left: 0;
            width: 20px;
            height: 20px;
            border: 1px solid rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 1000;
            display: none;
            transition: transform 0.2s ease, border-color 0.2s ease;
        }

        #cursor.hover {
            transform: translate(-50%, -50%) scale(1.5);
            border-color: var(--accent-color);
            background: rgba(0, 113, 227, 0.1);
        }

        @media (hover: hover) {
            #cursor {
                display: block;
            }

            body {
                cursor: none;
            }
        }

        /* Close instruction */
        .close-hint {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--text-secondary);
            font-size: 0.8rem;
            letter-spacing: 1px;
            opacity: 0;
            font-weight: 500;
        }
    </style>
</head>

<body>
    <div id="cursor"></div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div class="bg-particles"></div>
        <div class="ui-container">

            <!-- Insight Card -->
            <div class="card card-insight">
                <h3>Anomaly Detected</h3>
                <h1>73% Growth</h1>
                <div class="subtitle">Pattern matching indicates a significant upward trend in memory retention
                    clusters.</div>
            </div>

            <!-- Pie Chart Card -->
            <div class="card card-pie">
                <h3>Distribution</h3>
                <svg width="160" height="160" viewBox="0 0 100 100" class="pie-svg">
                    <circle cx="50" cy="50" r="32" stroke="rgba(0,0,0,0.05)" />
                    <circle cx="50" cy="50" r="32" stroke="var(--accent-color)" stroke-dasharray="75 100"
                        class="pie-segment" />
                </svg>
                <div style="margin-top: 15px; font-size: 2rem; font-weight: 600; color: var(--accent-color);">75%</div>
            </div>

            <!-- Bar Chart Card -->
            <div class="card card-bar">
                <h3>Yearly Metrics</h3>
                <div class="bar-chart">
                    <div class="bar-row">
                        <span class="bar-label">Q1</span>
                        <div class="bar-track">
                            <div class="bar-fill" data-width="45%"></div>
                        </div>
                    </div>
                    <div class="bar-row">
                        <span class="bar-label">Q2</span>
                        <div class="bar-track">
                            <div class="bar-fill" data-width="62%"></div>
                        </div>
                    </div>
                    <div class="bar-row">
                        <span class="bar-label">Q3</span>
                        <div class="bar-track">
                            <div class="bar-fill" data-width="88%"></div>
                        </div>
                    </div>
                    <div class="bar-row">
                        <span class="bar-label">Q4</span>
                        <div class="bar-track">
                            <div class="bar-fill" data-width="73%"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Sparkline Card -->
            <div class="card card-spark">
                <h3>Live Stream</h3>
                <svg width="100%" height="100%" viewBox="0 0 300 100" preserveAspectRatio="none">
                    <path d="M0,50 Q20,40 40,60 T80,50 T120,70 T160,30 T200,50 T240,40 T280,60 T300,50" fill="none"
                        stroke="var(--accent-secondary)" stroke-width="2" class="spark-path" />
                    <path d="M0,50 Q20,40 40,60 T80,50 T120,70 T160,30 T200,50 T240,40 T280,60 T300,50 V100 H0 Z"
                        fill="url(#grad1)" opacity="0.2" />
                    <defs>
                        <linearGradient id="grad1" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:var(--accent-secondary);stop-opacity:1" />
                            <stop offset="100%" style="stop-color:var(--accent-secondary);stop-opacity:0" />
                        </linearGradient>
                    </defs>
                </svg>
            </div>

            <!-- Tags -->
            <div class="card card-tags">
                <div class="pill">User Sentiment â†‘</div>
                <div class="pill">Seasonal Peak</div>
                <div class="pill">+127% YoY</div>
                <div class="pill"
                    style="border-color: var(--accent-secondary); color: var(--accent-secondary); background: rgba(52, 199, 89, 0.1);">
                    Beta Cluster</div>
            </div>

            <div class="close-hint">CLICK ANYWHERE TO CLOSE</div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- GSAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const CONFIG = {
            bubbleCount: 30,
            minSize: 0.8,
            maxSize: 3.0,
            floatSpeed: 0.005,
            connectionDistance: 15, // Increased for better connections
            animDuration: 0.6,
            fogColor: 0xffffff, // White fog for light mode
            fogDensity: 0.002 // Increased fog density by 30%
        };

        // --- Assets ---
        const imageUrls = [
            'https://images.unsplash.com/photo-1497436072909-60f4b65f3a2d?w=800&q=80',
            'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80',
            'https://images.unsplash.com/photo-1518717758536-85ae29035b6d?w=800&q=80',
            'https://images.unsplash.com/photo-1542291026-7eec264c27ff?w=800&q=80',
            'https://images.unsplash.com/photo-1552374196-c4e7ffc6e126?w=800&q=80',
            'https://images.unsplash.com/photo-1495467033336-2c4e4318fab8?w=800&q=80',
            'https://images.unsplash.com/photo-1531804055935-689e8412e5e9?w=800&q=80',
            'https://images.unsplash.com/photo-1483985988355-763728e7ce87?w=800&q=80'
        ];

        // --- Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff); // White background
        scene.fog = new THREE.FogExp2(CONFIG.fogColor, CONFIG.fogDensity);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 20); // Adjusted camera closer for tighter bubble cluster

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        container.appendChild(renderer.domElement);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = true;
        controls.enableZoom = true;
        controls.minDistance = 5;
        controls.maxDistance = 50; // Adjusted max zoom distance
        controls.maxPolarAngle = Math.PI;

        // --- Post Processing ---
        const renderScene = new RenderPass(scene, camera);
        // Reduced bloom for light mode to avoid washout
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.85; // Higher threshold so only very bright things bloom
        bloomPass.strength = 0.3;
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Brighter ambient
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        const pointLight = new THREE.PointLight(0x0071e3, 0.5, 20); // Blue tint
        pointLight.position.set(0, 0, 10);
        scene.add(pointLight);

        // --- Textures ---
        const textureLoader = new THREE.TextureLoader();
        const loadedTextures = imageUrls.map(url => {
            const tex = textureLoader.load(url);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        });

        // --- Bubble Logic ---
        const bubbles = [];
        const bubbleGeometry = new THREE.SphereGeometry(1, 64, 64);
        const innerGeometry = new THREE.SphereGeometry(0.9, 32, 32);

        const glassMaterialBase = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            metalness: 0.1,
            roughness: 0.05,
            transmission: 1.0,
            thickness: 1.5,
            ior: 1.5,
            reflectivity: 0.9,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            transparent: true,
            opacity: 1.0,
            side: THREE.DoubleSide
        });

        const bubbleTypes = [];
        for (let i = 0; i < 15; i++) bubbleTypes.push('green');
        for (let i = 0; i < 9; i++) bubbleTypes.push('yellow');
        for (let i = 0; i < 6; i++) bubbleTypes.push('red');

        function createBubble(index) {
            const group = new THREE.Group();
            const size = THREE.MathUtils.randFloat(CONFIG.minSize, CONFIG.maxSize);
            group.scale.set(size, size, size);

            // Reduced Random Position for closer spacing
            const rangeX = 30;
            const rangeY = 20;
            const rangeZ = 15;

            // Simple collision check during spawn to avoid initial overlaps
            let pos = new THREE.Vector3();
            let tooClose = true;
            let attempts = 0;

            while (tooClose && attempts < 50) {
                pos.set(
                    THREE.MathUtils.randFloat(-rangeX, rangeX),
                    THREE.MathUtils.randFloat(-rangeY, rangeY),
                    THREE.MathUtils.randFloat(-20, 5) // Deeper Z range
                );

                tooClose = false;
                for (let b of bubbles) {
                    const minDist = (size + b.userData.baseScale) * 1.5; // Reduced spacing multiplier
                    if (pos.distanceTo(b.position) < minDist) {
                        tooClose = true;
                        break;
                    }
                }
                attempts++;
            }

            group.position.copy(pos);

            const type = bubbleTypes[index];

            // User Data
            group.userData = {
                velocity: new THREE.Vector3(
                    THREE.MathUtils.randFloat(-CONFIG.floatSpeed, CONFIG.floatSpeed),
                    THREE.MathUtils.randFloat(-CONFIG.floatSpeed, CONFIG.floatSpeed),
                    THREE.MathUtils.randFloat(-CONFIG.floatSpeed, CONFIG.floatSpeed)
                ),
                rotationSpeed: new THREE.Vector3(
                    THREE.MathUtils.randFloat(-0.002, 0.002),
                    THREE.MathUtils.randFloat(-0.002, 0.002),
                    THREE.MathUtils.randFloat(-0.002, 0.002)
                ),
                baseScale: size,
                phase: Math.random() * Math.PI * 2,
                id: index,
                originalPos: new THREE.Vector3(),
                originalScale: new THREE.Vector3()
            };

            // Glass Shell
            const glassMat = glassMaterialBase.clone();
            let tint = 0xffffff;
            // Subtle tinting for light mode
            if (type === 'red') tint = 0xff3b30;
            else if (type === 'green') tint = 0x34c759;
            else if (type === 'yellow') tint = 0xffcc00;

            glassMat.color.setHex(tint);
            glassMat.attenuationColor = new THREE.Color(tint);
            glassMat.attenuationDistance = 5;

            const outerSphere = new THREE.Mesh(bubbleGeometry, glassMat);
            group.add(outerSphere);

            // Inner Image
            const tex = loadedTextures[Math.floor(Math.random() * loadedTextures.length)];
            const innerMat = new THREE.MeshBasicMaterial({
                map: tex,
                side: THREE.DoubleSide,
                toneMapped: false
            });
            const innerSphere = new THREE.Mesh(innerGeometry, innerMat);
            group.add(innerSphere);

            scene.add(group);
            bubbles.push(group);
        }

        for (let i = 0; i < CONFIG.bubbleCount; i++) {
            createBubble(i);
        }

        // --- Shards (Glass Shatter Effect) ---
        const shardGroup = new THREE.Group();
        scene.add(shardGroup);
        const shardCount = 50;
        const shards = [];
        const shardGeo = new THREE.ConeGeometry(0.2, 0.5, 3); // Triangular shards
        const shardMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            metalness: 0.2,
            roughness: 0.1,
            transmission: 0.9,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
        });

        for (let i = 0; i < shardCount; i++) {
            const mesh = new THREE.Mesh(shardGeo, shardMat);
            mesh.visible = false;
            shardGroup.add(mesh);
            shards.push({
                mesh: mesh,
                dir: new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize(),
                rot: new THREE.Vector3(Math.random(), Math.random(), Math.random())
            });
        }

        // --- Lines ---
        const lineGeometry = new THREE.BufferGeometry();
        const linePositions = new Float32Array(CONFIG.bubbleCount * CONFIG.bubbleCount * 6);
        lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
        // Darker lines for visibility on white
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.25, blending: THREE.NormalBlending, depthWrite: false });
        const linesMesh = new THREE.LineSegments(lineGeometry, lineMaterial);
        scene.add(linesMesh);

        // --- Interaction State ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(-100, -100);
        const cursorEl = document.getElementById('cursor');
        const uiLayer = document.getElementById('ui-layer');
        let activeBubble = null;
        let isDragging = false;
        let dragStartTime = 0;
        let isModeActive = false;

        // --- Event Listeners ---
        controls.addEventListener('start', () => { isDragging = true; dragStartTime = Date.now(); });
        controls.addEventListener('end', () => {
            if (Date.now() - dragStartTime < 150) isDragging = false;
            else setTimeout(() => { isDragging = false; }, 50);
        });

        window.addEventListener('mousemove', (e) => {
            cursorEl.style.left = e.clientX + 'px';
            cursorEl.style.top = e.clientY + 'px';
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        window.addEventListener('pointermove', (e) => {
            cursorEl.style.left = e.clientX + 'px';
            cursorEl.style.top = e.clientY + 'px';
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            if (e.pointerType === 'touch') e.preventDefault();
        });

        window.addEventListener('pointerup', onClick);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        function onClick(event) {
            if (isDragging) return;

            // If UI is active, clicking anywhere closes it
            if (isModeActive) {
                deactivateMode();
                return;
            }

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bubbles.map(b => b.children[0]));

            if (intersects.length > 0) {
                const targetGroup = intersects[0].object.parent;
                activateMode(targetGroup);
            }
        }

        // --- Mode Activation (The "Apple + Minority Report" Sequence) ---
        function activateMode(bubble) {
            isModeActive = true;
            activeBubble = bubble;

            // Store original state
            bubble.userData.originalPos.copy(bubble.position);
            bubble.userData.originalScale.copy(bubble.scale);

            // 1. Fade out others & push back
            bubbles.forEach(b => {
                if (b !== bubble) {
                    gsap.to(b.children[0].material, { opacity: 0.05, duration: 0.5 });
                    gsap.to(b.position, { z: b.position.z - 10, duration: 0.8, ease: "power2.out" });
                }
            });
            gsap.to(linesMesh.material, { opacity: 0, duration: 0.3 });

            // 2. Center Bubble & Enlarge
            const targetPos = new THREE.Vector3(0, 0, 12); // Close to camera
            targetPos.applyMatrix4(camera.matrixWorld); // Actually we want it relative to camera, but let's just put it at 0,0,15 world space if camera is at 0,0,20

            // Easier: Move bubble to (0,0,15)
            gsap.to(bubble.position, {
                x: 0, y: 0, z: 15,
                duration: 0.6,
                ease: "expo.inOut",
                onComplete: () => {
                    triggerShatter(bubble);
                }
            });

            // Scale up massively
            gsap.to(bubble.scale, {
                x: 5, y: 5, z: 5,
                duration: 0.6,
                ease: "expo.inOut"
            });
        }

        function triggerShatter(bubble) {
            // Hide bubble
            bubble.visible = false;

            // Position shards at bubble center
            shardGroup.position.copy(bubble.position);
            shardGroup.rotation.set(0, 0, 0);

            // Explode shards
            shards.forEach((shard, i) => {
                shard.mesh.visible = true;
                shard.mesh.position.set(0, 0, 0);
                shard.mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);

                // Random explode direction
                const dist = 3 + Math.random() * 2;
                gsap.to(shard.mesh.position, {
                    x: shard.dir.x * dist,
                    y: shard.dir.y * dist,
                    z: shard.dir.z * dist,
                    duration: 1.5,
                    ease: "power2.out"
                });

                gsap.to(shard.mesh.rotation, {
                    x: shard.rot.x * 10,
                    y: shard.rot.y * 10,
                    duration: 2,
                    ease: "none"
                });

                // Fade out shards
                gsap.to(shard.mesh.material, { opacity: 0, delay: 0.5, duration: 1 });
            });

            // Show UI
            showUI();
        }

        function showUI() {
            uiLayer.classList.add('active');
            gsap.to(uiLayer, { opacity: 1, duration: 0.5 });

            // Animate Cards In (Staggered Slide)
            const cards = document.querySelectorAll('.card');
            gsap.fromTo(cards,
                { opacity: 0, y: 50, scale: 0.95, rotationX: 10 },
                { opacity: 1, y: 0, scale: 1, rotationX: 0, duration: 0.8, stagger: 0.1, ease: "back.out(1.2)" }
            );

            // Animate Bar Charts
            const bars = document.querySelectorAll('.bar-fill');
            bars.forEach(bar => {
                const w = bar.getAttribute('data-width');
                gsap.fromTo(bar, { width: '0%' }, { width: w, duration: 1.5, ease: "power2.out", delay: 0.5 });
            });

            // Animate Pie
            const pie = document.querySelector('.pie-segment');
            gsap.fromTo(pie, { strokeDasharray: "0 100" }, { strokeDasharray: "75 100", duration: 1.5, ease: "power2.out", delay: 0.5 });

            // Animate Pills
            const pills = document.querySelectorAll('.pill');
            gsap.fromTo(pills,
                { opacity: 0, x: 20 },
                { opacity: 1, x: 0, duration: 0.5, stagger: 0.1, delay: 0.8 }
            );

            // Show close hint
            gsap.to('.close-hint', { opacity: 1, delay: 2, duration: 1 });
        }

        function deactivateMode() {
            if (!activeBubble) return;
            isModeActive = false;

            // Hide UI
            gsap.to(uiLayer, {
                opacity: 0, duration: 0.4, onComplete: () => {
                    uiLayer.classList.remove('active');
                }
            });

            // Reverse Shards (Implode)
            // Reset shard opacity
            shards.forEach(s => s.mesh.material.opacity = 0.8);

            // Tween shards back to center
            shards.forEach(shard => {
                gsap.to(shard.mesh.position, {
                    x: 0, y: 0, z: 0,
                    duration: 0.6,
                    ease: "power2.in"
                });
            });

            // After implode, show bubble and move back
            setTimeout(() => {
                shards.forEach(s => s.mesh.visible = false);
                activeBubble.visible = true;

                // Move bubble back
                gsap.to(activeBubble.position, {
                    x: activeBubble.userData.originalPos.x,
                    y: activeBubble.userData.originalPos.y,
                    z: activeBubble.userData.originalPos.z,
                    duration: 0.8,
                    ease: "power2.inOut"
                });

                gsap.to(activeBubble.scale, {
                    x: activeBubble.userData.originalScale.x,
                    y: activeBubble.userData.originalScale.y,
                    z: activeBubble.userData.originalScale.z,
                    duration: 0.8,
                    ease: "power2.inOut"
                });

                // Fade others back in
                bubbles.forEach(b => {
                    if (b !== activeBubble) {
                        gsap.to(b.children[0].material, { opacity: 1, duration: 0.8 });
                        gsap.to(b.position, { z: b.userData.originalPos.z, duration: 0.8 });
                    }
                });
                gsap.to(linesMesh.material, { opacity: 0.25, duration: 0.8 });

                activeBubble = null;

            }, 600); // Wait for implode
        }


        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            controls.update();

            // Cursor Hover Logic
            if (!isModeActive) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(bubbles.map(b => b.children[0]));
                if (intersects.length > 0) {
                    cursorEl.classList.add('hover');
                    document.body.style.cursor = 'pointer';
                } else {
                    cursorEl.classList.remove('hover');
                    document.body.style.cursor = 'default';
                }
            } else {
                document.body.style.cursor = 'default';
            }

            // Bubble Float Animation
            bubbles.forEach(bubble => {
                if (isModeActive && bubble === activeBubble) return; // Don't animate selected bubble

                const data = bubble.userData;
                bubble.position.add(data.velocity);
                bubble.rotation.x += data.rotationSpeed.x;
                bubble.rotation.y += data.rotationSpeed.y;

                // Breathing
                const breath = Math.sin(time * 0.5 + data.phase) * 0.08;
                const s = data.baseScale * (1 + breath);
                // Only apply breathing if not selected/animating
                if (!isModeActive) bubble.scale.set(s, s, s);

                // Bounds
                const limitX = 30, limitY = 20; // Updated bounds to match spawn range
                if (bubble.position.x > limitX || bubble.position.x < -limitX) data.velocity.x *= -1;
                if (bubble.position.y > limitY || bubble.position.y < -limitY) data.velocity.y *= -1;
                if (bubble.position.z > 10 || bubble.position.z < -20) data.velocity.z *= -1;

                // Simple Repulsion to prevent overlap
                if (!isModeActive) {
                    for (let other of bubbles) {
                        if (bubble !== other) {
                            const dist = bubble.position.distanceTo(other.position);
                            const minGap = (data.baseScale + other.userData.baseScale) * 1.0;
                            if (dist < minGap) {
                                const push = bubble.position.clone().sub(other.position).normalize().multiplyScalar(0.02);
                                bubble.position.add(push);
                            }
                        }
                    }
                }
            });

            // Lines Update
            if (!isModeActive) {
                let vertexIndex = 0;
                const positions = linesMesh.geometry.attributes.position.array;

                for (let i = 0; i < bubbles.length; i++) {
                    for (let j = i + 1; j < bubbles.length; j++) {
                        const dist = bubbles[i].position.distanceTo(bubbles[j].position);
                        if (dist < CONFIG.connectionDistance) {
                            positions[vertexIndex++] = bubbles[i].position.x;
                            positions[vertexIndex++] = bubbles[i].position.y;
                            positions[vertexIndex++] = bubbles[i].position.z;
                            positions[vertexIndex++] = bubbles[j].position.x;
                            positions[vertexIndex++] = bubbles[j].position.y;
                            positions[vertexIndex++] = bubbles[j].position.z;
                        }
                    }
                }
                // Clear remaining
                for (let k = vertexIndex; k < positions.length; k++) positions[k] = 0;
                linesMesh.geometry.attributes.position.needsUpdate = true;
            }

            composer.render();
        }

        animate();
    </script>
</body>

</html>