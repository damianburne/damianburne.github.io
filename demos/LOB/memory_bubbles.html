<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Memory Bubbles</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #ffffff;
            font-family: 'Inter', sans-serif;
            cursor: none;
            /* Hide default cursor */
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #cursor {
            position: fixed;
            top: 0;
            left: 0;
            width: 20px;
            height: 20px;
            border: 1px solid rgba(0, 0, 0, 0.2);
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 1000;
            transition: width 0.2s, height 0.2s, background-color 0.2s;
            mix-blend-mode: difference;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        #cursor.hover {
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.8);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ccc;
            font-size: 12px;
            letter-spacing: 2px;
            pointer-events: none;
            z-index: 0;
        }

        /* Soft Modern Textbox */
        #info-box {
            position: absolute;
            top: 50%;
            left: 50%;
            /* Center it, or maybe offset if the bubble is centered? Let's center it over the bubble */
            transform: translate(-50%, -50%) scale(0.9);
            width: 90%;
            max-width: 400px;
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(30px) saturate(180%);
            -webkit-backdrop-filter: blur(30px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.6);
            padding: 40px;
            border-radius: 32px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            opacity: 0;
            visibility: hidden;
            transition: all 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
            z-index: 100;
            text-align: center;
            pointer-events: none;
            /* Let clicks pass through to dismiss? No, we might want to select text. */
        }

        #info-box.visible {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }

        #info-box h2 {
            margin: 0 0 16px 0;
            font-weight: 600;
            font-size: 24px;
            color: #1d1d1f;
            letter-spacing: -0.02em;
        }

        #info-box p {
            margin: 0;
            font-size: 16px;
            line-height: 1.6;
            color: #424245;
        }
    </style>
</head>

<body>
    <div class="loading">INITIALIZING MEMORIES...</div>
    <div id="cursor"></div>

    <div id="info-box">
        <h2>Memory Fragment</h2>
        <p>A fleeting moment captured in time. The red hue signifies a core memory, deeply embedded and vividly
            recalled. It represents passion, intensity, and the warmth of human connection.</p>
    </div>

    <div id="canvas-container"></div>

    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- GSAP for animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const CONFIG = {
            bubbleCount: 60,
            minSize: 0.5,
            maxSize: 2.5,
            floatSpeed: 0.005,
            repulsionRadius: 5,
            repulsionForce: 0.05,
            fogColor: 0xffffff,
            fogDensity: 0.015,
            bloomStrength: 0.3,
            bloomRadius: 0.5,
            bloomThreshold: 0.85,
            connectionDistance: 8 // Distance to draw lines
        };

        // --- Assets ---
        const imageUrls = [
            'https://images.unsplash.com/photo-1497436072909-60f4b65f3a2d?w=800&q=80',
            'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80',
            'https://images.unsplash.com/photo-1518717758536-85ae29035b6d?w=800&q=80',
            'https://images.unsplash.com/photo-1542291026-7eec264c27ff?w=800&q=80',
            'https://images.unsplash.com/photo-1552374196-c4e7ffc6e126?w=800&q=80',
            'https://images.unsplash.com/photo-1495467033336-2c4e4318fab8?w=800&q=80',
            'https://images.unsplash.com/photo-1531804055935-689e8412e5e9?w=800&q=80',
            'https://images.unsplash.com/photo-1483985988355-763728e7ce87?w=800&q=80'
        ];

        const videoUrl = 'https://assets.mixkit.co/videos/preview/mixkit-abstract-video-with-colorful-smoke-1559-small.mp4';

        // --- Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);
        scene.fog = new THREE.FogExp2(CONFIG.fogColor, CONFIG.fogDensity);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        container.appendChild(renderer.domElement);

        // --- Post Processing ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloomThreshold;
        bloomPass.strength = CONFIG.bloomStrength;
        bloomPass.radius = CONFIG.bloomRadius;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // --- Textures ---
        const textureLoader = new THREE.TextureLoader();
        const loadedTextures = [];

        imageUrls.forEach(url => {
            const tex = textureLoader.load(url);
            tex.colorSpace = THREE.SRGBColorSpace;
            loadedTextures.push(tex);
        });

        const video = document.createElement('video');
        video.src = videoUrl;
        video.loop = true;
        video.muted = true;
        video.playsInline = true;
        video.crossOrigin = "anonymous";
        video.play();
        const videoTexture = new THREE.VideoTexture(video);
        videoTexture.colorSpace = THREE.SRGBColorSpace;
        loadedTextures.push(videoTexture);

        // --- Bubble Logic ---
        const bubbles = [];
        const bubbleGeometry = new THREE.SphereGeometry(1, 64, 64);
        const innerGeometry = new THREE.SphereGeometry(0.9, 32, 32);

        const glassMaterialBase = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            metalness: 0.1,
            roughness: 0.05,
            transmission: 1.0,
            thickness: 1.5,
            ior: 1.5,
            reflectivity: 0.9,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            transparent: true,
            opacity: 1.0,
            side: THREE.DoubleSide
        });

        const tintColors = [
            0xffffff, // Clear
            0xffffff,
            0xffffff,
            0xdddddd, // Light Grey
            0x222222, // Dark Grey
            0x88ccaa, // Emerald
            0x88aacc, // Blue
            0xccaa88  // Amber
        ];

        const redTint = 0xff3b30; // Apple Red

        function createBubble(index) {
            const group = new THREE.Group();

            const size = THREE.MathUtils.randFloat(CONFIG.minSize, CONFIG.maxSize);
            group.scale.set(size, size, size);

            const range = 15;
            group.position.set(
                THREE.MathUtils.randFloat(-range, range),
                THREE.MathUtils.randFloat(-range / 2, range / 2),
                THREE.MathUtils.randFloat(-10, 5)
            );

            // Determine if this is a "Red" bubble (first 6)
            const isRed = index < 6;

            group.userData = {
                velocity: new THREE.Vector3(
                    THREE.MathUtils.randFloat(-CONFIG.floatSpeed, CONFIG.floatSpeed),
                    THREE.MathUtils.randFloat(-CONFIG.floatSpeed, CONFIG.floatSpeed),
                    THREE.MathUtils.randFloat(-CONFIG.floatSpeed, CONFIG.floatSpeed)
                ),
                rotationSpeed: new THREE.Vector3(
                    THREE.MathUtils.randFloat(-0.002, 0.002),
                    THREE.MathUtils.randFloat(-0.002, 0.002),
                    THREE.MathUtils.randFloat(-0.002, 0.002)
                ),
                baseScale: size,
                phase: Math.random() * Math.PI * 2,
                id: index,
                isExpanded: false,
                isRed: isRed,
                originalPos: new THREE.Vector3(),
                originalScale: new THREE.Vector3()
            };

            // Outer Glass Shell
            const glassMat = glassMaterialBase.clone();
            if (isRed) {
                glassMat.color.setHex(redTint);
                glassMat.attenuationColor = new THREE.Color(redTint);
                glassMat.attenuationDistance = 5;
            } else {
                const tint = tintColors[Math.floor(Math.random() * tintColors.length)];
                glassMat.color.setHex(tint);
            }

            const outerSphere = new THREE.Mesh(bubbleGeometry, glassMat);
            group.add(outerSphere);

            // Inner Image/Video Sphere
            const tex = loadedTextures[Math.floor(Math.random() * loadedTextures.length)];
            const innerMat = new THREE.MeshBasicMaterial({
                map: tex,
                side: THREE.DoubleSide,
                toneMapped: false
            });
            const innerSphere = new THREE.Mesh(innerGeometry, innerMat);
            innerSphere.rotation.y = Math.random() * Math.PI;
            innerSphere.rotation.z = Math.random() * Math.PI * 0.1;
            group.add(innerSphere);

            scene.add(group);
            bubbles.push(group);
        }

        for (let i = 0; i < CONFIG.bubbleCount; i++) {
            createBubble(i);
        }

        // --- Lines (Plexus) ---
        // We'll use a BufferGeometry that we update every frame
        const maxConnections = CONFIG.bubbleCount * CONFIG.bubbleCount; // Worst case
        const lineGeometry = new THREE.BufferGeometry();
        const linePositions = new Float32Array(maxConnections * 6); // 2 points * 3 coords
        lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));

        const lineMaterial = new THREE.LineBasicMaterial({
            color: 0xaaaaaa,
            transparent: true,
            opacity: 0.15,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const linesMesh = new THREE.LineSegments(lineGeometry, lineMaterial);
        scene.add(linesMesh);


        // --- Interaction ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(-100, -100);
        const cursorEl = document.getElementById('cursor');
        const infoBox = document.getElementById('info-box');
        let activeBubble = null;

        function onMouseMove(event) {
            cursorEl.style.left = event.clientX + 'px';
            cursorEl.style.top = event.clientY + 'px';
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onClick(event) {
            // If clicking on the info box, don't dismiss immediately (optional, but safer)
            // But we have pointer-events: none on box unless visible.

            if (activeBubble) {
                dismissBubble();
                return;
            }

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bubbles.map(b => b.children[0]));

            if (intersects.length > 0) {
                const targetGroup = intersects[0].object.parent;
                expandBubble(targetGroup);
            }
        }

        function expandBubble(bubble) {
            activeBubble = bubble;
            bubble.userData.isExpanded = true;
            bubble.userData.originalPos.copy(bubble.position);
            bubble.userData.originalScale.copy(bubble.scale);

            const dist = 8;
            const targetPos = new THREE.Vector3(0, 0, -dist);
            targetPos.applyMatrix4(camera.matrixWorld);

            gsap.to(bubble.position, {
                x: targetPos.x,
                y: targetPos.y,
                z: targetPos.z,
                duration: 1.5,
                ease: "power3.out"
            });

            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const height = 2 * Math.tan(vFOV / 2) * dist;
            const targetScale = height * 0.35;

            gsap.to(bubble.scale, {
                x: targetScale,
                y: targetScale,
                z: targetScale,
                duration: 1.5,
                ease: "back.out(1.2)"
            });

            gsap.to(bubble.rotation, { x: 0, y: 0, z: 0, duration: 1.5 });

            const outerMesh = bubble.children[0];
            gsap.to(outerMesh.material, {
                roughness: 0,
                thickness: 0.1,
                duration: 1
            });

            // Show Textbox if Red
            if (bubble.userData.isRed) {
                infoBox.classList.add('visible');
            }

            // Auto-dismiss
            gsap.delayedCall(6, () => {
                if (activeBubble === bubble) dismissBubble();
            });
        }

        function dismissBubble() {
            if (!activeBubble) return;
            const bubble = activeBubble;
            activeBubble = null;
            bubble.userData.isExpanded = false;

            gsap.to(bubble.position, {
                x: bubble.userData.originalPos.x,
                y: bubble.userData.originalPos.y,
                z: bubble.userData.originalPos.z,
                duration: 1.2,
                ease: "power2.inOut"
            });

            gsap.to(bubble.scale, {
                x: bubble.userData.originalScale.x,
                y: bubble.userData.originalScale.y,
                z: bubble.userData.originalScale.z,
                duration: 1.2,
                ease: "power2.inOut"
            });

            const outerMesh = bubble.children[0];
            gsap.to(outerMesh.material, {
                roughness: 0.05,
                thickness: 1.5,
                duration: 1.2
            });

            // Hide Textbox
            infoBox.classList.remove('visible');
        }

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onClick);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            // Update Cursor Hover
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bubbles.map(b => b.children[0]));
            if (intersects.length > 0) {
                cursorEl.classList.add('hover');
            } else {
                cursorEl.classList.remove('hover');
            }

            // Update Bubbles & Lines
            let vertexIndex = 0;
            const positions = linesMesh.geometry.attributes.position.array;

            bubbles.forEach((bubble, i) => {
                if (bubble.userData.isExpanded) return;

                const data = bubble.userData;

                // Movement
                bubble.position.add(data.velocity);
                bubble.rotation.x += data.rotationSpeed.x;
                bubble.rotation.y += data.rotationSpeed.y;

                // Breathing
                const breath = Math.sin(time * 0.5 + data.phase) * 0.08;
                const s = data.baseScale * (1 + breath);
                bubble.scale.set(s, s, s);

                // Bounds
                const limitX = 25, limitY = 15;
                if (bubble.position.x > limitX || bubble.position.x < -limitX) data.velocity.x *= -1;
                if (bubble.position.y > limitY || bubble.position.y < -limitY) data.velocity.y *= -1;
                if (bubble.position.z > 5 || bubble.position.z < -15) data.velocity.z *= -1;

                // Mouse interaction
                const screenPos = bubble.position.clone().project(camera);
                const dx = screenPos.x - mouse.x;
                const dy = screenPos.y - mouse.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 0.5) {
                    bubble.position.x -= dx * 0.002;
                    bubble.position.y -= dy * 0.002;
                }

                // Collision
                for (let j = i + 1; j < bubbles.length; j++) {
                    const other = bubbles[j];
                    if (other.userData.isExpanded) continue;

                    const dist3d = bubble.position.distanceTo(other.position);
                    const minDist = (bubble.scale.x + other.scale.x) * 0.5;

                    if (dist3d < minDist) {
                        const pushDir = new THREE.Vector3().subVectors(bubble.position, other.position).normalize();
                        bubble.position.addScaledVector(pushDir, 0.02);
                        data.velocity.addScaledVector(pushDir, 0.001);
                    }

                    // Lines Logic
                    if (dist3d < CONFIG.connectionDistance) {
                        // Add line segment
                        positions[vertexIndex++] = bubble.position.x;
                        positions[vertexIndex++] = bubble.position.y;
                        positions[vertexIndex++] = bubble.position.z;

                        positions[vertexIndex++] = other.position.x;
                        positions[vertexIndex++] = other.position.y;
                        positions[vertexIndex++] = other.position.z;
                    }
                }
            });

            // Clear remaining line vertices
            for (let k = vertexIndex; k < positions.length; k++) {
                positions[k] = 0;
            }

            linesMesh.geometry.attributes.position.needsUpdate = true;
            linesMesh.geometry.setDrawRange(0, vertexIndex / 3);

            composer.render();
        }

        animate();
    </script>
</body>

</html>